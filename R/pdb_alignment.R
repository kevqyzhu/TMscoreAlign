# Purpose: Write and visualize PDB file
# Author: Kevin Zhu
# Date: 12.10.2023
# Version: 1.0.0
# Bugs and Issues: N/A

#' Write Transformed Coordinates to PDB File
#'
#' This function writes the transformed coordinates obtained from a structure
#' alignment to a new PDB file. The transformed coordinates are generated by
#' applying the alignment parameters to the original coordinates of the second
#' protein structure. The resulting PDB file includes the transformed
#' coordinates alongside the original coordinates of the first structure.
#'
#' @param alignment List. Structure alignment results, including alignment
#'  parameters and transformed coordinates.
#'   The list should contain the following elements:\cr
#'   - coord1: 3D coordinates (matrix) of CA atoms for common residues in the
#'      first structure.\cr
#'   - coord2: 3D coordinates (matrix) of CA atoms for common residues in the
#'      second structure.\cr
#'   - values: Numeric vector. Alignment parameters obtained from structure
#'    alignment.\cr
#'   - rmsd: Numeric. Root Mean Square Deviation (RMSD) between the two protein
#'    structures.
#' @param outputfile Character. The name of the output PDB file to be created
#'  (default: "out.pdb").
#' @param appended Logical. If TRUE, the transformed coordinates are appended to
#'  the original coordinates
#'   in the output PDB file. If FALSE, the output PDB file contains only the
#'    transformed coordinates.
#' @param pdb1 Character. Path to the PDB file of the first protein structure.
#' @param pdb2 Character. Path to the PDB file of the second protein structure.
#' @param chain_1 Character. Chain identifier for the first protein structure.
#' @param chain_2 Character. Chain identifier for the second protein structure.
#'
#' @return No return value but a PDB file is written.
#'
#' @examples
#' \dontrun{
#' # Example: Write transformed coordinates to a new PDB file
#' pdb_file1 <- system.file("extdata", "1LNIA_decoy1_4.pdb",
#'                           package="TMscoreAlign")
#' pdb_file2 <- system.file("extdata", "1LNIA_decoy2_180.pdb",
#'                           package="TMscoreAlign")
#' alignment_results <- get_alignment(pdb_file1, pdb_file2,
#'                                     chain1 = 'A', chain2 = 'A',
#'                                     method = "alignment")
#' write_pdb(alignment_results, outputfile = "aligned_structure.pdb",
#'          appended = TRUE, pdb1 = pdb_file1, pdb2 = pdb_file2,
#'          chain_1 = 'A', chain_2 = 'A')
#' }
#'
#' @references
#' Berman, H., Henrick, K. and Nakamura, H.
#' Announcing the worldwide Protein Data Bank.
#' \emph{Nature Structural & Molecular Biology}, 10, 980 (2003).
#' \href{https://doi.org/10.1038/nsb1203-980}{Link}
#'
#' @seealso
#' \code{\link{get_alignment}} for obtaining structural alignment between two
#'   protein structures.
#' \code{\link{get_matrix}} for obtaining the transformation matrix from
#'   alignment parameters.
#'
#' @export
#' @importFrom bio3d atom.select read.pdb clean.pdb trim.pdb cat.pdb
write_pdb <- function(alignment, outputfile = "out.pdb", appended = TRUE,
                      pdb1, pdb2, chain_1, chain_2) {
  if (typeof(alignment) != "list") {
    stop("Alignment type must be List.")
  }

  if (!setequal(names(alignment), c("N", "coord1", "coord2", "values"))) {
    stop("Alignment does not have the correct elements.")
  }

  if (typeof(alignment$N) != "integer") {
    stop("The N in alignment must be an integer.")
  }

  if (length(dim(alignment$coord1)) != 2 |
      length(dim(alignment$coord2)) != 2) {
    stop("The coord1 and coord2 matrices in alignment must be 2D matrices.")
  }

  if (dim(alignment$coord1)[1] != 4 |
      dim(alignment$coord2)[1] != 4) {
    stop("The first dimension of coord1 and coord2 matrices must be 4.")
  }

  if (dim(alignment$coord1)[2] != alignment$N |
      dim(alignment$coord2)[2] != alignment$N) {
    stop("The second dimension of coord1 and coord2 matrices must be equal to
         N.")
  }

  if (!is.vector(alignment$values)) {
    stop("The values in alignment must be a vector.")
  }

  if (!setequal(names(alignment$values),
                c("dx", "dy", "dz", "theta", "phi", "psi"))) {
    stop("The values in alignment does not have the correct elements.")
  }

  if (typeof(appended) != "logical") {
    stop("appended must be logical type.")
  }

  if (!file.exists(pdb1)) {
    stop("File path to pdb1 does not exist.")
  }

  if (!file.exists(pdb2)) {
    stop("File path to pdb2 does not exist.")
  }

  if (!is.character(chain_1) | !is.character(chain_2)) {
    stop("Chain identifiers must be characters.")
  }

  # Extract values from the alignment object
  values <- alignment$values

  # Get the transformation matrix based on alignment values
  matrix <- get_matrix(values)

  # Process the first PDB file
  pdb_data1 <- bio3d::clean.pdb(
    bio3d::read.pdb(pdb1),
    consecutive = FALSE,
    force.renumber = TRUE,
    fix.chain = TRUE)

  # Process the second PDB file
  pdb_data2 <- clean.pdb(
    read.pdb(pdb2),
    consecutive = FALSE,
    force.renumber = TRUE,
    fix.chain = TRUE)

  if (!(chain_1 %in% unique(pdb_data1$atom$chain))) {
    stop("Chain 1 ID is invalid.")
  }
  if (!(chain_2 %in% unique(pdb_data2$atom$chain))) {
    stop("Chain 2 ID is invalid.")
  }

  # Select atoms from the first chain
  sele_1 <- atom.select(pdb_data1, chain = chain_1)

  # Trim the PDB data to retain only selected atoms from the first chain
  pdb1_chain1_data <- bio3d::trim.pdb(pdb_data1, sele_1)

  # Select atoms from the second chain
  sele_2 <- bio3d::atom.select(pdb_data2, chain = chain_2)

  # Trim the PDB data to retain only selected atoms from the second chain
  pdb2_chain2_data <- bio3d::trim.pdb(pdb_data2, sele_2)

  # Transform atom coordinates from second PDB file using the alignment matrix
  xyz <- cbind(pdb2_chain2_data$atom[, c("x", "y", "z")], 1)
  transformed_xyz <- matrix %*% t(as.matrix(xyz))
  transformed_xyz_df <- as.data.frame(t(transformed_xyz))
  transformed_xyz_df <- transformed_xyz_df[, -ncol(transformed_xyz_df)]
  pdb2_chain2_data$atom[, c("x", "y", "z")] <- transformed_xyz_df
  pdb2_chain2_data$xyz[,] <- c(t(transformed_xyz_df))

  # Check if the PDB files need to be appended
  if (appended) {
    # Concatenate PDB data if 'appended' is TRUE
    new.pdb <- suppressWarnings(bio3d::cat.pdb(
      pdb1_chain1_data,
      pdb2_chain2_data,
      rechain = TRUE,
      renumber = TRUE))
  } else {
    # Otherwise, use only the second PDB data
    new.pdb <- pdb2_chain2_data
  }

  # Write the final PDB data to a new file
  bio3d::write.pdb(pdb = new.pdb, xyz = new.pdb$xyz, file = outputfile)

}

#' Visualize Protein Structure Alignment Using 3Dmol
#'
#' This function visualizes the structural alignment of two protein structures
#' by displaying the aligned coordinates in a 3D viewer. The viewer is set up
#' using 3Dmol, and the alignment is represented by color-coded cartoon-style
#' structures for each protein chain.
#'
#' @param alignment_pdb Character. Path to the PDB file containing the aligned
#'  coordinates. The PDB file should include both the original and
#'  transformed coordinates of the protein structures.
#' @param chain1 Character. Color code (hexadecimal) for the first protein
#'  structure (default: "#636efa").
#' @param chain2 Character. Color code (hexadecimal) for the second protein
#'  structure (default: "#ff7f0e").
#'
#' @return A 3Dmol viewer displaying the aligned protein structures.
#'
#' @examples
#' \dontrun{
#' # Example: Visualize protein structure alignment
#' pdb_file1 <- system.file("extdata", "1LNIA_decoy1_4.pdb",
#'                           package="TMscoreAlign")
#' pdb_file2 <- system.file("extdata", "1LNIA_decoy2_180.pdb",
#'                           package="TMscoreAlign")
#' alignment_results <- get_alignment(pdb_file1, pdb_file2,
#'                                     chain1 = 'A', chain2 = 'A',
#'                                     method = "alignment")
#' write_pdb(alignment_results, outputfile = "aligned_structure.pdb",
#'          appended = TRUE, pdb1 = pdb_file1, pdb2 = pdb_file2,
#'          chain_1 = 'A', chain_2 = 'A')
#' alignment_pdb_file <- "aligned_structure.pdb"
#' chain1_color <- "#636efa"  # Blue
#' chain2_color <- "#ff7f0e"  # Orange
#' visualize_alignment_pdb(alignment_pdb_file, chain1 = chain1_color,
#'                         chain2 = chain2_color)
#' }
#'
#' @references
#' Su W, Johnston B (2021). r3dmol: Create Interactive 3D Visualizations of
#' Molecular Data. R package version 0.1.2.
#' \href{https://CRAN.R-project.org/package=r3dmol}{Link}.
#'
#' @seealso
#' \code{\link{write_pdb}} for generating a PDB file with transformed
#'   coordinates.
#' \code{\link{get_alignment}} for obtaining structural alignment between two
#'   protein structures.
#'
#' @export
#' @import r3dmol
visualize_alignment_pdb <- function(alignment_pdb = "out.pdb",
                                    chain1 = "#636efa", chain2 = "#ff7f0e") {
  if (!file.exists(alignment_pdb)) {
    stop("File path to alignment_pdb does not exist.")
  }
  if (!is.character(chain1) | !is.character(chain2)) {
    stop("Chain color identifiers must be characters.")
  }

  return(
    r3dmol(                         # Set up the initial viewer
      viewer_spec = m_viewer_spec(
        cartoonQuality = 40,
        lowerZoomLimit = 50,
        upperZoomLimit = 350
      )
    ) %>%
      m_add_model(                  # Add model to scene
        data = alignment_pdb,
        format = "pdb"
      ) %>%
      m_zoom_to() %>%               # Zoom to encompass the whole scene
      m_set_style(                  # Style the first chain
        sel = m_sel(chain = "A"),
        style = m_style_cartoon(
          color = chain1,
          arrows = TRUE
        )
      ) %>%
      m_set_style(                  # Style the second chain
        sel = m_sel(chain = "B"),
        style = m_style_cartoon(
          color = chain2,
          arrows = TRUE
        )
      ) %>%
      m_rotate(                     # Rotate the scene
        angle = 90,
        axis = "y"
      ) %>%
      m_spin()                      # Animate the chains by spinning them
  )
}
